---
id: use-cases
title: Use cases
---

# Use cases

We truly believe there is no project or specialist that could not benefit from Drill4J.

## Project stage

- **Fresh projects** with little to no tests implemented yet - to grow a healthy and efficient test library.
- **Mature projects** which are still in active development - to reduce regression testing time and find untested appliation areas.
- **Legacy projects** - with lots of code and lots of tests - to find unused code and remove redundant tests.
- **Projects in maintenance/KTLO** - where only occasional patches/hotfixes are introduced - to spend less time figuring out what to test.

## Job function

- **Everyone** - get a complete and continious metrics for each application version, for any test type, for all parts of the system. Track how changes to tests and code impact your coverage.
- **Test automation engineers** - find and cover testing gaps with ease;
- **Manual QA engineers** - reduce manual work, know exactly what to test;
- **Developers** - see which code was touched by the failed test without additional logging.

As a bonus Drill4J provides a common ground for QA engineers and developers to go from, as each test now generates a comprehensive coverage report.

## Area of responsibility

Drill4J is modular and can be installed for system as a whole, or only for the particular part. It comes in handy, if you work in multi-team or even multi-vendor projects.

## Architecture

Depending on your application architecture, Drill4J can be configured in any way:

- for monolithic service;
- for microservices;
- for WEB frontend application;
- for all of the above;

## Testing types

Drill4J allows

- API tests (including implemented in Java/JVM languages or in Node with JavaScript/Typescript, or even POSTMAN);
- Automated UI tests (Selenium, Cypress);
- Unit tests;
- Manual tests (for Chrome/Chromium-based browsers).
- all of the above.
