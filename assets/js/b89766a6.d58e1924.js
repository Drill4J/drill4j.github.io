(self.webpackChunkdrill4j_github_io=self.webpackChunkdrill4j_github_io||[]).push([[2633],{1233:function(e,t,n){"use strict";n(7294)},5757:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return s},metadata:function(){return c},toc:function(){return d},default:function(){return p}});var o=n(2122),a=n(9756),r=(n(7294),n(3905)),i=n(549),s=(n(1233),{id:"core-concepts",title:"Core Concepts"}),c={unversionedId:"core-concepts",id:"core-concepts",isDocsHomePage:!1,title:"Core Concepts",description:"1. Service Packages Configuration",source:"@site/docs/core-concept.mdx",sourceDirName:".",slug:"/core-concepts",permalink:"/docs/core-concepts",version:"current",frontMatter:{id:"core-concepts",title:"Core Concepts"},sidebar:"docs",previous:{title:"Supported Frameworks",permalink:"/docs/supported-frameworks"},next:{title:"FAQ",permalink:"/docs/faq"}},d=[{value:"1. Service Packages Configuration",id:"1-service-packages-configuration",children:[]},{value:"2. Runtime Code Instrumentation with JaCoCo",id:"2-runtime-code-instrumentation-with-jacoco",children:[{value:"JaCoCo Overview",id:"jacoco-overview",children:[]},{value:"Code Coverage Calculation Algorithm",id:"code-coverage-calculation-algorithm",children:[]}]},{value:"3. Context Propagation",id:"3-context-propagation",children:[]},{value:"4. Metrics Calculation",id:"4-metrics-calculation",children:[{value:"Risked Methods",id:"risked-methods",children:[]},{value:"Recommended Tests",id:"recommended-tests",children:[]}]}],l={toc:d};function p(e){var t=e.components,n=(0,a.Z)(e,["components"]);return(0,r.kt)("wrapper",(0,o.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)(i.Ee,{src:"/img/core-concept-diagram.jpg",mdxType:"Image"}),(0,r.kt)("h2",{id:"1-service-packages-configuration"},"1. Service Packages Configuration"),(0,r.kt)("p",null,"The Drill4J Agent sends the application structure (packages\\classes\\methods) to the Drill admin panel. ",(0,r.kt)("br",null),"\nUser is able to configure which service (application) packages will be instrumented. It can be done on the 2nd step of agent registration in the field ",(0,r.kt)("strong",{parentName:"p"},"Application Packages"),"."),(0,r.kt)(i.Ee,{src:"/img/agent-registration-step2.png",mdxType:"Image"}),(0,r.kt)("p",null,"A line with hyphenation turns into an array of strings for backend."),(0,r.kt)("h2",{id:"2-runtime-code-instrumentation-with-jacoco"},"2. Runtime Code Instrumentation with JaCoCo"),(0,r.kt)("p",null,"Code is instrumented with JaCoCo. Instrumentation allows the Drill4J agent to track code execution during tests. All instrumentation is happening in runtime. There is no need to change either original sources nor build files."),(0,r.kt)("h3",{id:"jacoco-overview"},"JaCoCo Overview"),(0,r.kt)("p",null,"JaCoCo is a free code coverage library for Java, that calculates coverage by ",(0,r.kt)("strong",{parentName:"p"},"probes"),". ",(0,r.kt)("br",null),"\n",(0,r.kt)("strong",{parentName:"p"},"Probes")," - boolean array. ",(0,r.kt)("br",null),"\nFor example: ",(0,r.kt)("br",null),"\n",(0,r.kt)("strong",{parentName:"p"},"[f,f,f,f,f,f,f.......]"),", where ",(0,r.kt)("strong",{parentName:"p"},"f")," - false means that in the process, our thread of execution did not come across a line of code. This probes list exists for each class.\nProbes are placed in different places (e.g.):"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"at the beginning of the method"),(0,r.kt)("li",{parentName:"ul"},"at the beginning of the branch block")),(0,r.kt)("h3",{id:"code-coverage-calculation-algorithm"},"Code Coverage Calculation Algorithm"),(0,r.kt)("p",null,"First, probes are put down with the help of instrumentation in the source code.\nWhen the code is executed, the probe becomes ",(0,r.kt)("strong",{parentName:"p"},"TRUE")," in the boolean array. ",(0,r.kt)("br",null),"\nAnalysis of all probes and coverage calculation is described in ",(0,r.kt)("a",{parentName:"p",href:"https://www.jacoco.org/jacoco/trunk/index.html"},"documentation"),". ",(0,r.kt)("br",null),"\nBytecode instrumentation is described in ",(0,r.kt)("a",{parentName:"p",href:"https://www.baeldung.com/java-instrumentation"},"documentation"),"."),(0,r.kt)("h2",{id:"3-context-propagation"},"3. Context Propagation"),(0,r.kt)("p",null,"Autotest Agent tracks code execution for each test separately and reports these data to Drill4J Admin Backend.\nIt integrates with various ",(0,r.kt)("a",{parentName:"p",href:"/docs/supported-frameworks"},"testing frameworks")," and configures Selenium to add headers to the HTTP requests.\nIt's necessary to connect a particular test of a User with a Drill4J agent, we need to add additional information in the form of a ",(0,r.kt)("strong",{parentName:"p"},"User identifier")," (session id) and a ",(0,r.kt)("strong",{parentName:"p"},"test identifier")," within HTTP requests.\nWe implement an interceptor for each (supported) client (e.g. Apache, okhttp, Netty) using instrumentation."),(0,r.kt)("h2",{id:"4-metrics-calculation"},"4. Metrics Calculation"),(0,r.kt)("p",null,"Drill4J Admin Backend calculates the following metrics:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"test coverage "),(0,r.kt)("li",{parentName:"ul"},"associated tests"),(0,r.kt)("li",{parentName:"ul"},"covered methods"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/core-concepts#risked-methods"},"risked methods")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/core-concepts#recommended-tests"},"recommended tests")),(0,r.kt)("li",{parentName:"ul"},"quality gate status")),(0,r.kt)("h3",{id:"risked-methods"},"Risked Methods"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Risked methods")," are ",(0,r.kt)("strong",{parentName:"p"},"New")," or/and ",(0,r.kt)("strong",{parentName:"p"},"Modified")," methods detected in a new application build. Risk is considered covered if it was covered on ",(0,r.kt)("strong",{parentName:"p"},"any")," percent. ",(0,r.kt)("br",null),"\n",(0,r.kt)("strong",{parentName:"p"},"E.g.")," in the current build 1000 New methods (200 uncovered), 500 modified (101 uncovered), than risked methods number = 200 + 101 = 301 risked methods. ",(0,r.kt)("br",null),"\nLambdas aren't displayed as the risked method and not taken in build difference calculation.\nA risked method has 3 states:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"not covered "),(0,r.kt)("li",{parentName:"ul"},"partially covered"),(0,r.kt)("li",{parentName:"ul"},"fully covered")),(0,r.kt)("h3",{id:"recommended-tests"},"Recommended Tests"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Recommended tests")," are tests that should be run at first to check changes of code in a new application build.\nThe set of recommended tests is formed by Test to Code mapping. It's a relationship between a particular test with the executed part of code."),(0,r.kt)(i.Ee,{src:"/img/test-to-code-mapping.png",mdxType:"Image"}),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"E.g."),"  In the first application build tests are mapped to code. The second application build has 3 modified methods which were covered by 2 test cases (autotests).\nRelated to this information, we recommend to run only 2 test cases in order to check only modified code and don't waste time to run cases that aren't check something useful. ",(0,r.kt)("br",null),"\nAlso, we recommend writing new autotests or modify existing autotests to cover new methods."),(0,r.kt)(i.Ee,{src:"/img/recommended-tests.png",mdxType:"Image"}))}p.isMDXComponent=!0}}]);